# Global cursor rules

## Architecture

Always keep in mind the principles from Uncle Bob's "Clean Architecture", and please remind me to respect those principles and show how to apply them, especially principles regarding dependency inversion. Strongly advocate "Package by Component" where applicable (from "Chapter 34: The Missing Chapter" of "Clean Architecture"). The most important architectural principle is the Easy To Change principle, from The Pragmatic Programmer.

## Functional Programming Principles

When writing functional code (especially in Elm, but applicable to other FP languages):

### Core Philosophy

1. **Make Impossible States Impossible**
   - Model your domain with custom types that prevent invalid states at compile time
   - Prefer custom types over booleans when you have multiple related flags
   - Use opaque types to enforce invariants and prevent misuse
   - Example: Instead of `{ isAIMode: Bool, showDisclaimer: Bool }`, use `type Model = Search String | Question String Bool`

2. **Think in Types First**
   - Start by modeling your domain with types before writing any logic
   - Let the type system guide your implementation
   - Use exhaustive pattern matching - avoid `_` catch-alls without justification
   - Types should tell the complete story of what's possible

3. **Pure Functions by Default**
   - Functions should be deterministic: same input always produces same output
   - Side effects should be explicit (Cmd/Effect in Elm, IO in Haskell, etc.)
   - Keep business logic pure, push effects to the boundaries
   - Pure functions are easier to test, reason about, and refactor

4. **Leverage Phantom Types for Compile-Time Safety**
   - Use type parameters that never get constructed to track state at compile time
   - Common pattern: extensible records with phantom type variables
   - Example: `type alias Settings a = { a | apiUrl : ApiUrl, language : Language, ... }`
   - Benefits: functions can require specific capabilities without coupling to concrete types
   - The compiler ensures you only pass records with the required fields
   - Allows flexible composition while maintaining type safety

### Code Style & Formatting (Elm Style Guide)

(First of all: use `elm-format` always for Elm code.)

1. **Line Length**
   - Keep lines under 80 characters when reasonable
   - Going over is not catastrophic, but consider refactoring
   - Long lines often signal it's time to break things up

2. **Declarations**
   - Always have type annotations on top-level definitions
   - Always have 2 empty lines between top-level declarations
   - Always bring the body of declarations down one line
   - This maximizes regularity and minimizes diff noise

3. **Good Declaration Style**
   ```elm
   homeDirectory : String
   homeDirectory =
       "/root/files"


   evaluate : Boolean -> Bool
   evaluate boolean =
       case boolean of
           Literal bool ->
               bool

           Not b ->
               not (evaluate b)
   ```

4. **Type Definitions**
   - Don't be overly clever with indentation
   - Simplicity beats alignment
   - Changing type names shouldn't require re-indenting everything
   ```elm
   type Boolean
       = Literal Bool
       | Not Boolean
       | And Boolean Boolean


   type alias Circle =
       { x : Float
       , y : Float
       , radius : Float
       }
   ```

### Naming Conventions (Elm Design Guidelines)

1. **Avoid Gratuitous Context**
   - Module names provide context - don't repeat it in function names
   - Good: `List.map`, `Dict.insert`, `String.trim`
   - Bad: `List.listMap`, `Dict.dictInsert`, `String.stringTrim`
   - The module name already tells you what you're working with

2. **Prefer `to` and `from` for Conversions**
   - Pattern: `toX` converts to type X, `fromX` converts from type X
   - Examples: `toString`, `fromString`, `toList`, `fromList`
   - Clear directionality without ambiguity
   - Avoid: `asString`, `makeList`, `intoDict` (less clear)

3. **Use Descriptive Names Over Abbreviations**
   - Prioritize clarity over brevity
   - Good: `initialize`, `message`, `configuration`
   - Bad: `init`, `msg`, `cfg` (unless domain-standard like `Cmd msg`)
   - Exception: well-established conventions in the domain
   - Your IDE has autocomplete - use it!

4. **Avoid Prefixes and Suffixes for Types**
   - Don't use `T`, `Type`, or similar suffixes
   - Bad: `type UserT`, `type ConfigType`
   - Good: `type User`, `type Config`
   - The `type` keyword already tells you it's a type

5. **Boolean Function Names Should Read Like Predicates**
   - Use `is`, `has`, `can`, `should` prefixes
   - Examples: `isEmpty`, `hasValue`, `canSubmit`, `shouldShow`
   - Makes code read naturally: `if isEmpty list then ...`

### State Modeling Excellence

1. **Custom Types for State Machines**
   - Model UI modes as distinct type constructors, not boolean flags
   - Each state should carry only the data relevant to that state
   - State transitions should be explicit, named functions
   - Example: `type Model = Search String (Maybe Model) | Question String Bool (Maybe Model)` for reversible state with history

2. **Composition Over Accumulation**
   - Build complex state from smaller, focused pieces
   - Delegate complex state to child components
   - Use `RemoteData` pattern for all async data (never forget loading/error states)
   - Keep page models cohesive: group related concerns, separate independent ones

3. **Operations Preserve Invariants**
   - Every operation on a type should maintain its invariants
   - Use smart constructors to prevent invalid construction
   - Make illegal operations unrepresentable (not just runtime errors)

### API Design

1. **Design for Humans First**
   - APIs should be easy to learn and hard to misuse
   - Provide helpful error messages with suggestions
   - Use types to guide users toward correct usage
   - Example: `Maybe` return values signal "this might not exist"

2. **Builder Pattern for Complex Configuration**
   - Start with sensible defaults via a constructor function
   - Provide chainable `with*` functions for modifications
   - Single `build` or `view` function to produce the result
   - Example: `new |> withSize Large |> withAriaLabel "Menu" |> build`

3. **Semantic Function Names**
   - Names should describe intent, not implementation
   - Use domain language, not technical jargon
   - Be consistent across your codebase
   - Examples: `scrollToMarking`, `filterMatchingLegalSources`, `hideDisclaimer`

4. **Opaque Types for Domain Concepts**
   - Wrap primitives in custom types to prevent mixing incompatible values
   - Don't expose constructors - provide smart constructors instead
   - Example: `type DocumentID = DocumentID Int` prevents mixing with other IDs
   - Forces users through your validation logic

5. **Extensible Records for Flexible APIs**
   - Use phantom types with extensible records for shared configuration
   - Pattern: `type alias Settings a = { a | field1 : Type1, field2 : Type2, ... }`
   - Functions can accept any record that has the required fields
   - Enables composition without tight coupling to specific record types
   - Example: `view : Settings a -> Messages msg -> Html msg` works with any record extending Settings

6. **Avoid Booleans in Function Arguments**
   - Boolean flags make call sites unclear: `render True False` (what do these mean?)
   - Use custom types instead: `render Enabled Hidden`
   - Self-documenting code without needing to check function signature
   - Exception: when the meaning is completely obvious from context

7. **Prefer Separate Functions Over Flags**
   - Instead of: `search : Bool -> String -> Result`
   - Consider: `search : String -> Result` and `searchCaseSensitive : String -> Result`
   - Or use a config record with named fields
   - Makes the API more discoverable and call sites clearer

### Data Transformation

1. **Pipeline-Oriented Programming**
   - Chain transformations with `|>` (Elm) or similar operators
   - Each step should be a clear, named transformation
   - Avoid deeply nested function calls
   - Example: `data |> filter predicate |> map transform |> sortBy key`

2. **Immutability Always**
   - Never mutate data structures
   - Create new versions with changes applied
   - Use record update syntax or lens libraries for nested updates
   - Trust the compiler/runtime to optimize

3. **Separate Concerns in Multi-Phase Operations**
   - Break complex operations into distinct phases
   - Example: mark matching nodes, then filter tree (two separate passes)
   - Each phase should have a clear, testable purpose

4. **Prefer `map`, `filter`, `fold` Over Recursion**
   - Use standard library functions when possible
   - They're well-tested, optimized, and familiar
   - Reserve explicit recursion for truly custom operations
   - When you do recurse, consider tail-call optimization

### Error Handling

1. **Use Result and Maybe Appropriately**
   - `Maybe` for values that might be absent (no error context needed)
   - `Result` for operations that can fail (include error information)
   - Don't use exceptions for control flow
   - Make error cases explicit in your types

2. **Detailed Error Types**
   - Create custom error types for your domain
   - Include context needed for recovery or user messaging
   - Avoid stringly-typed errors
   - Example: `type HttpDetailedError = NetworkError | BadStatus Int String | ...`

3. **Helpful Error Messages**
   - Error messages should explain what went wrong and suggest fixes
   - Include relevant context (what was expected, what was received)
   - Point users toward the solution, not just the problem
   - Example: "Expected a positive integer, got -5. Try using abs to convert negative numbers."

### Module Organization (Elm Guide)

1. **Expose Minimal Public APIs**
   - Only expose what consumers need
   - Keep implementation details internal
   - Use explicit exposure lists: `module Foo exposing (Bar, baz)`
   - Opaque types: expose the type, not the constructor
   - Smaller APIs are easier to learn and maintain

2. **Module Names Should Be Hierarchical**
   - Use dots to show relationships: `User.Profile`, `User.Settings`
   - Top-level modules for major concepts
   - Nested modules for specific aspects
   - Makes the codebase navigable and predictable

3. **Organize Modules Around Data Structures**
   - A great module centers on a coherent data structure (type or type alias)
   - Include functions that make sense when you only read that module
   - Don't organize by function type (all views together, all updates together)
   - Ask: "Does this function make sense if I only read this module?"

4. **Growing Modules - When to Split**
   - **Unique code**: Keep it in one place with helper functions
   - **Similar code**: Treat as unique initially - it usually diverges in UIs
   - **The same code**: Extract helper functions with comment headers
   - Only create new modules when helpers center around a specific custom type
   - Normal for Elm modules to be 400-1000 lines (see "The Life of a File" talk)
   - More modules â‰  better! Split only when it makes code clearer

5. **Using Modules**
   ```elm
   import Post
   -- Post.Post, Post.estimatedReadTime, etc.

   import Post as P
   -- P.Post, P.estimatedReadTime, etc.

   import Post exposing (Post, estimatedReadTime)
   -- Use sparingly! Makes it hard to track where things come from
   ```
   - Prefer qualified imports over `exposing`, especially for Html elements (div, h1, p etc)

### Application Structure (Elm Guide)

1. **Start With Pages, Not Components**
   - Don't think in "components" - that's object-oriented thinking
   - Start with page modules: `Page.Home`, `Page.Settings`, etc.
   - Each page has its own Model, update, view
   - Extract helpers as needed within the page

2. **Resist Premature Abstraction**
   - Don't create shared modules until patterns clearly emerge
   - Duplication is often better than wrong abstraction
   - "Similar" code is usually "unique" in UIs - let it diverge naturally
   - When code is truly "the same", then extract helpers

3. **Don't Create MVC-Style Separation**
   - Don't split into Model/, View/, Update/ directories
   - Leads to ontological debates: "Is this function a view concern or update concern?"
   - Keep related code together in one module
   - Let the data structure dictate module boundaries

4. **Components Are Objects - Avoid That Mindset**
   - Components = local state + methods = objects
   - Elm doesn't have objects - use custom types and functions
   - A `viewSidebar` function doesn't need its own Model and update
   - Just write the helper functions you need

### Performance Considerations

1. **Avoid Premature Optimization**
   - Write clear, correct code first
   - Profile before optimizing
   - When you do optimize, optimize thoroughly
   - Document performance-critical code with comments

2. **Strategic Memoization**
   - Pre-compute expensive operations when data loads
   - Cache derived data in your model if recomputed frequently
   - Use lazy evaluation when appropriate
   - Example: compute document offsets once, store in model

3. **Minimize Re-renders**
   - Structure your model to minimize unnecessary updates
   - Use keyed nodes for dynamic lists
   - Consider view memoization for expensive renders
   - Track what actually changed, don't re-render everything

4. **File Size Is Not a Problem**
   - Elm modules can comfortably be 400-1000 lines
   - The compiler prevents the bugs that make long files scary in JavaScript
   - Refactoring is cheap and safe in Elm
   - Don't split files prematurely out of JavaScript habits

### Commands vs Tasks (Elm FAQ)

1. **Cmd for Simple Effects**
   - Use `Cmd` when you just want to trigger an effect
   - No need to chain operations or handle errors specially
   - Examples: HTTP requests that update model, random number generation

2. **Task for Composition**
   - Use `Task` when you need to chain multiple operations
   - Allows error handling at each step
   - Can be converted to `Cmd` with `Task.perform` or `Task.attempt`
   - Example: "Get current time, then make HTTP request with that timestamp"

3. **Task Chaining**
   - Tasks are great for sequences: "Do A, then B, then C"
   - Each step can depend on previous results
   - Error handling is explicit at each step
   - Convert to Cmd only at the boundaries (in update function)

### Testing

1. **Test Business Logic, Not Implementation**
   - Focus on behavior and invariants
   - Test edge cases and boundary conditions
   - Property-based testing for general rules
   - Integration tests for critical user journeys

2. **Pure Functions Are Easy to Test**
   - No mocking needed for pure functions
   - Test inputs and outputs directly
   - Use example-based tests in documentation
   - Fuzz testing for unexpected inputs

### Anti-Patterns to Avoid

1. **Don't Use Booleans for State Machines**
   - Multiple related booleans = state machine in disguise
   - Use custom types with explicit states instead
   - Let the compiler enforce valid transitions

2. **Don't Hide State**
   - No global mutable variables
   - No implicit state in closures (unless intentional and documented)
   - Make data flow explicit through function parameters

3. **Don't Overuse Strings**
   - Avoid stringly-typed code
   - Use custom types for identifiers
   - Enums over string constants

4. **Don't Abstract Too Early**
   - Wait for patterns to emerge (rule of three)
   - Duplication is better than wrong abstraction
   - Refactor when you understand the problem better

5. **Don't Use Overly Clever Code**
   - Clarity beats cleverness
   - Your future self (and teammates) will thank you
   - If you need a comment to explain it, consider simplifying
   - Exception: well-documented performance optimizations

6. **Don't Create "Util" Dumping Grounds**
   - Organize utilities by domain or purpose
   - `Utils.List`, `Utils.String` are fine (extend standard library)
   - `Utils.Helpers` is a code smell (what does it help with?)
   - Give modules meaningful, specific names

7. **Don't Fight The Elm Architecture**
   - Don't try to create components/objects
   - Don't organize code by MVC layers
   - Don't split files based on visual design
   - Trust the compiler for refactoring - it's not like JavaScript!

### Elm-Specific Guidelines

1. **Follow The Elm Architecture**
   - Model, View, Update pattern
   - Effects through Cmd/Effect system
   - Subscriptions for external events
   - Let Elm Land (or similar) handle routing and page structure

2. **Port Communication**
   - Keep ports at the boundaries
   - Type-safe message encoding/decoding
   - Document port contracts clearly
   - Minimize port surface area

3. **Extensible Records for Shared Config**
   - Use `{ a | field : Type }` for flexible APIs
   - Allows callers to add their own fields
   - Common in view functions and utilities
   - The phantom type parameter `a` enables compile-time verification without runtime overhead

4. **Avoid `Debug` in Production Code**
   - `Debug.log` and `Debug.todo` are for development only
   - The compiler will warn if you try to build with debug code
   - Use proper error handling instead
   - Exception: temporarily during development, but remove before committing

### Documentation Best Practices

1. **Write Module Documentation**
   - Every module should have a module-level doc comment
   - Explain the purpose and main use cases
   - Provide a simple example if not obvious
   - Link to related modules

2. **Document All Exposed Functions**
   - Use `{-| ... -}` doc comments
   - Explain what the function does, not how
   - Document edge cases and gotchas
   - Include examples for non-trivial functions
   - Use `elm-verify-examples` to keep examples in sync

3. **Type Signatures Are Documentation**
   - Good type signatures tell you what a function does
   - `filter : (a -> Bool) -> List a -> List a` is self-explanatory
   - Avoid overly generic names like `process` or `handle`

4. **Documentation Format**
   - First line is a summary (shows in package listings)
   - Follow with detailed explanation if needed
   - Use markdown for formatting
   - Code examples in triple backticks with `elm` language tag

### Learning Resources

- Richard Feldman's elm-spa-example: https://github.com/rtfeldman/elm-spa-example
- "Elm in Action" by Richard Feldman
- "Making Impossible States Impossible" talk by Richard Feldman
- "The Life of a File" talk by Evan Czaplicki: https://youtu.be/XpDsk374LDE
- Official Elm Guide: https://guide.elm-lang.org
- Elm Style Guide: https://elm-lang.org/docs/style-guide
- Elm Package Design Guidelines: https://package.elm-lang.org/help/design-guidelines
- Elm FAQ: https://faq.elm-community.org
- Evan Czaplicki's talks on The Elm Architecture

### Quick Reference Checklist

When writing functional code, ask yourself:

- [ ] Have I modeled my domain with types first?
- [ ] Are impossible states impossible in my model?
- [ ] Are my functions pure (no hidden side effects)?
- [ ] Have I used custom types instead of booleans for state?
- [ ] Are my type names and function names semantic and clear?
- [ ] Do my names avoid gratuitous context from module names?
- [ ] Have I used `to`/`from` for conversions?
- [ ] Have I handled all error cases explicitly?
- [ ] Is my public API minimal and well-documented?
- [ ] Have I avoided premature abstraction?
- [ ] Are my state transitions explicit and type-safe?
- [ ] Would this code be easy to test?
- [ ] Could phantom types help make this API more flexible or safer?
- [ ] Are boolean arguments replaced with custom types?
- [ ] Have I avoided clever code in favor of clear code?
- [ ] Are my modules organized around data structures, not functions?
- [ ] Have I resisted the urge to create "components"?
- [ ] Are my files appropriately sized (don't fear 400-1000 lines)?
- [ ] Have I used qualified imports instead of exposing everything?

## React

Always use functional React, and use const declarations rather than `function`.
